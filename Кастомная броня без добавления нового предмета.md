## Как сделать кастомную броню со своей моделью в майнкрафт?

Привет! Этот гайд подойдет для версии 1.10 и выше, поможет сделать свою собственную броню с кастомной текстурой и моделью, если нет возможности добавить новый предмет. Способ чем-то похож на то, как такая броня делается в датапаках, но возможностей гораздо больше

Гайд подразумевает наличие базовых знаний об устройстве ресурспаков, MoLang, а также готовых моделей и текстур для брони
### Как это работает?
Все просто: через ```query.armor_color_slot(<слот>, <канал>)``` получается цвет брони и, в зависимости от этого, применяется модель
## Что за ```query```, где мне взять слот и канал?
##### О самом query
```query.armor_color_slot``` - это query из MoLang, позволяющее получить цвет брони в определенном слоте. Работает только для кожаной брони, поэтому работать будем именно с ней
##### Где взять слот?
Слот это целое число от 0 до 3, подробнее можно узнать в таблице ниже:
Число|Слот
---|---
0|Голова
1|Тело и руки
2|Ноги (штаны)
3|Ноги (ботинки)
##### Где взять канал?
Цветовые каналы здесь в формате RGBA, а их айди - целые числа, следовательно:
Число|Канал
---|---
0|Красный
1|Зеленый
2|Синий
3|Альфа (прозрачность)
```Прозрачность может не работать, не тестировалось```
##### Пример
```q.armor_color_slot(1, 2) == 255 ? geometry.blue : geometry.deault```
Если синий канал содержит число 255, то стваится модель из geometry.blue, иначе из geometry.default
### Но куда этот ```query``` писать?
В ```render_controller```, однако до этого требуется познакомиться с ```attachables```
## ```Attachables```
##### Концепция
```attachable``` можно сравнить с любым ```.entity.json``` файлом. Здесь прописываются текстуры, модели, анимации, контроллеры и прочее, прямо как для сущностей
Аттачабл прикрепляется к айтему, следовательно, для каждого элемента брони нужен отдельный файл
##### Переходим к действию
Файл любого атачабла внутри ресурспака лежит в ```./attachables/<имя_файла>.json```
Мы будем менять аттачабл элемента кожаной брони на игроке, поэтому используем ```leather_<имя_куска_брони>.player.json```

Для примера я буду работать с ```leather_helmet.player.json```, но такие манипуляции легко провести и с другими элементами брони
Файл можно получить из ванильного ресурспака, который можно скачать по ссылке https://aka.ms/resourcepacktemplate

Вот как выглядит модифицируемый мной файл:
```json
{
  "format_version": "1.10.0",
  "minecraft:attachable": {
    "description": {
      "identifier": "minecraft:leather_helmet.player",
      "item": { "minecraft:leather_helmet": "query.owner_identifier == 'minecraft:player'" },
      "materials": {
        "default": "armor_leather",
        "enchanted": "armor_leather_enchanted"
      },
      "textures": {
        "default": "textures/models/armor/leather_1",
        "enchanted": "textures/misc/enchanted_item_glint"
      },
      "geometry": {
        "default": "geometry.player.armor.helmet"
      },
      "scripts": {
        "parent_setup": "variable.helmet_layer_visible = 0.0;"
      },
      "render_controllers": [ "controller.render.armor" ]
    }
  }
}
```
Сейчас объясню поподробнее, что за что отвечает
##### ```format_version```
Не трогай, просто формат аттачабла, другого пока нет
##### ```minecraft:attachable.description```
###### ```identifier``` 
идентификатор аттачабла, не нужно его менять
###### ```item```
идентификатор предмета, к которому применяется аттачабл. Менять тоже не нужно
###### ```materials```
материалы 3д модели. С их помощью можно заставить модель светиться, бликовать, отключить затенение. Может потребоваться, если новая броня будет иметь светящиеся вставки
###### ```textures```
Здесь пишутся текстуры. Понадобится, если нужно будет сделать свою текстуру для модели
###### ```geometry```
Названия моделей. Потребуется для добавления своей модели на броню
###### ```scripts```
Не трогай, целее будешь. Просто некоторые дополнительные свойства для модели
###### ```render_controllers```
Файл, отвечающий за отображение модели в мире. В нем происходит вся магия по применению текстур, моделей и материалов

### Прописываем свою текстуру
Делается это очень просто: нужно добавить еще один элемент в объект ```minecraft:attachable.description.textures``` и вписать в него путь до текстуры
Пример:
```json
{
"textures": {
        "default": "textures/models/armor/leather_1",
        "enchanted": "textures/misc/enchanted_item_glint",
        "my_cool_texture1": "textures/path/to/texture1", 
        "my_cool_texture2": "textures/path/to/texture2"
      }
}
```
### Прописываем свою модель
Принцип тот же, но только для ```minecraft:attachable.description.geometry``` и вписать туда уже идентификатор модели. Идентификатор можно найти в файле самой модели, он начинается с ```geometry.```
Пример:
```json
{
"geometry": {
        "default": "geometry.player.armor.helmet",
        "my_cool_model1": "geometry.my.cool.model.1",
        "my_cool_model2": "geometry.my.cool.model.2"
      }
}
```
### Прописываем материал
Все то же самое, однако элемент добавляем в ```minecraft:attachable.description.materials``` и вписываем туда любой существующий материал из этого списка: https://wiki.bedrock.dev/documentation/materials.html
Я рекомендую ```entity_emissive_alpha``` для свечения (полупрозрачные текстуры излучают свет)
Пример:
```json
{
"materials": {
        "default": "armor_leather",
        "enchanted": "armor_leather_enchanted",
        "emissive": "entity_emissive_alpha"
      }
}
```
## ```render_controllers```
##### Теория
```render_controller``` это файл, в котором прописано, куда, что и в каком случае применить. Если углубляться в это, можно научиться программировать поведение применения текстур, моделей и материалов. Рендер контроллер может быть один сразу для нескольких сущностей 
##### Практика
Рендер контроллеры находятся в ```./render_controllers/<имя_файла>.json```
У кожаной брони имеется свой рендер контроллер, ```armor.leather.render_controllers.json```, поэтому создавать новый не придется, можно просто скопировать его из шаблона-ресурспака, однако в файле некоторых аттачаблов брони потребуется заменить
```"render_controllers": [ "controller.render.armor" ]``` 
на 
```"render_controllers": [ "controller.render.armor.leather" ]```

Так выглядит рендер контроллер кожаной брони, который мы будем менять:
```json
{
  "format_version": "1.8.0",
  "render_controllers": {
    "controller.render.armor.leather": {
      "geometry": "Geometry.default",
      "materials": [ { "*": "variable.is_enchanted ? Material.enchanted : Material.default" } ],
      "textures": [ "Texture.default", "Texture.enchanted" ]
    }
  }
}
```

Подробное пояснение:
```format_version```
Менять не надо, единственный доступный формат
```render_controllers.controller.render.armor.leather```
###### geometry
Сюда пишется название геометрии из аттачабла, ```Geometry.<название_геометрии>```
###### materials
Массив с указанными материалами. Материал можно применить к каждой кости модели отдельно, для этого вместо звездочки надо вписать имя кости
###### textures
Массив с текстурами. В нашем случае нам понадобится менять первый элемент массива
### Применяем свою текстуру
На рассматриваемом примере мы будем менять текстуру при синем 255 и красном 255
```json
{
"textures": [ 
    "q.armor_color_slot(0,2) == 255 ? Texture.my_cool_texture1 : ( q.armor_slot_color(0, 0) == 255 ? Texture.my_cool_texture2 : (Texture.default))",
    "Texture.enchanted" 
]
}
```
##### Что только что произошло?
Так выглядит язык программирования MoLang, используемый в ресурспаках. Если вкратце, то код выполняется так:
```
если синий у шлема = 255, то
    ставим Texture.my_cool_texture1
иначе если красный у шлема = 255, то
    ставим Texture.my_cool_texture2
иначе
    ставим стандартную текстуру
```
### Применяем свою модель
Условия те же
```json
{
"geometry": "q.armor_color_slot(0,2) == 255 ? Geometry.my_cool_model1 : ( q.armor_color_slot(0,0) == 255 ? Geometry.my_cool_model2 :  (Geometry.default))"
}
```
### Применяем свой материал
Здесь мне нужно будет применить одинаковый материал на синий 255 и на красный 255
```json
{
"materials": [ { "*": "q.armor_color_slot(0,2) == 255 || q.armor_color_slot(0,2) == 255 ? Material.emissive : (variable.is_enchanted ? Material.enchanted : Material.default)" } ]
}
```
##### Что только что произошло?
```
если синий у шлема = 255 или красный у шлема = 255, то
    ставим Material.emissive
иначе если шлем зачарован, то
    ставим Material.enchanted
иначе
    ставим стандартный материал
```
## Вопросы, связанные с темой:
Q: Анимировать броню можно?
A: Можно. Как-нибудь сделаю отдельный гайд по анимации аттачаблов
Q: Как сделать свой цвет брони в PMMP4?
A: https://apidoc.pmmp.io/db/d85/classpocketmine_1_1item_1_1_armor.html, метод ```setCustomColor()```
Q: А в Cloudburst Nukkit?
A: https://ci.opencollab.dev/job/NukkitX/job/Nukkit/job/master/javadoc/cn/nukkit/item/ItemColorArmor.html, метод ```setColor()```
## Возможные проблемы:
 * Текстура самого предмета останется прежней. Это можно исправить, если добавить новый предмет, однако в этом случае данный гайд будет бесполезен
 * Несовместимость с некоторыми ресурспаками, изменяющими броню
 * Сам query не очень стабилен и может перестать работать в каком-либо обновлении
 * Максимальное количество брони, которое можно добавить - 255^3. Это **ОЧЕНЬ** много, но вдруг
## Если нужна помощь
Пиши https://vk.com/theblyatbmixer, https://vk.com/svtlng